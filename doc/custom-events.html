<html>
<head>
<title>Sider 7 Lua Module Programmers Guide</title>
<style>
body { margin-left: 1em; margin-right: 1em; margin-bottom: 2em; }
body,h1,h2,h3,h4,h5,p,ol,ul,li,td,th { font-family: sans-serif; }
h1 { margin-bottom: 0; color: #000; }
h4 { color: #660066; margin-top: 0.1em; margin-bottom: 0.1em; }
h3 { color: #113399; text-decoration: underline; margin-top: 1.8em; }
.warn { color: #660000; padding: 0 0.5em 0 0.5em; border-left: 0.5em solid #880000; border-right: 0.5em solid #880000; background-color: #ccbbbb; }
.gwarn { color: #666666; padding: 0 0.5em 0 0.5em; border-left: 0.5em solid #888888; border-right: 0.5em solid #888888; background-color: #cccccc; }
.bluenote { color: #003388; padding: 0 0.5em 0 0.5em; border-left: 0.5em solid #003388; border-right: 0.5em solid #003388; background-color: #bbc0dd; }
.note { color: #336600; padding: 0 0.5em 0 0.5em; border-left: 0.5em solid #336600; border-right: 0.5em solid #336600; background-color: #bbccbb; }
pre { color: #003366; padding: 0.3em 0.5em 0.3em 0.5em; background-color: #dde5ff; font-family: monospace;
    border-top: solid 1px #4477aa; font-size: 0.9em;
}
.user { font-weight: bold; color: #2255aa; }
.soft { font-weight: bold; color: #336600; }
.pathname { font-weight: normal; font-family: monospace; color: #336600; }
.file { font-weight: normal; font-family: monospace; color: #660099; }
.func { font-weight: bold; font-family: monospace; color: #660099; margin-top: 1.5em; margin-bottom: 0.6em; }
.desc { margin-top: 0.6em; }
.kitattr { font-weight: normal; font-family: monospace; color: #000099; }
.evt { font-weight: bold; font-family: monospace; }
.evthdr { padding: 0 0 0 0.5em; border-left: 0.5em solid #bbb; background-color: #eee; margin-top: 1.5em; }
.auf { font-weight: bold; color: #336600; }
a { color: #33f; }
a.top { float: right; padding-top: 1em; }
th { text-align: left; background-color: #d0ccdd; }
th,td { border-top: 1px solid #888; padding: 0.2em 0.5em 0.5em 0.5em; }
.last { border-bottom: 1px solid #888; }
table.inputs { margin-left: 3em; }
table.inputs tr th,td { border-left: 1px solid #888; }
table.inputs tr th { font-weight: bold; font-family: sans-serif; background-color: #eee; color: #660099;
    border-top: 1px solid #888; border-bottom: 1px solid #888; }
table.inputs tr td { font-family: sans-serif; border-top: none; border-bottom: 1px solid #888; }
table.inputs tr td.right,th.right { border-right: 1px solid #888; }
</style>
</head>

<body>
<h1>Sider 7 Lua Module Programmers Guide: Custom events</h1>
<h4>For sider.dll version: 7.3</h4>

<a href="scripting.html">Back to scripting guide</a> |
<a href="readme.html">Back to readme</a>

<p>New in sider 7.3.0 is the support for Lua modules to both generate and handle
custom events. These are events that are NOT generated by sider. Instead, it is the
responsibility of a Lua module to do so.</p>

<p class="bluenote">The original idea of custom events belongs to <span class="user">FerJo75</span>
from EvoWeb.uk forums. We worked together to research and test various aspects of this
complex new feature of sider. The final implementation choices/details might be mine,
but the original concept and the vision are all by <span class="user">FerJo75</span>. Without
him none of this would have existed.</p>

<p class="note">This is a rather advanced topic, so if you really want to get a good
understanding of what is going on here and how things work, be prepared to dome some
extra reading outside of this guide, when necessary. There is only so much detail
i can go into here, but if you feel lost and confused, don't lose heart: things are
not as difficult as they look, once you start digging in.</p>

<p>We will be working with assembly language and even sometimes directly
wich machine code instructions, as well as Lua on the other side. It can be very exciting
and rewarding experience, but also very frustrating, when things do not work right away.
This is a rather wild mix of high level and very low level programming, so be prepared to be patient
and not allow the frustration of crashes and bugs to get the better of you ;)</p>

<p>With this fair warning out of the way, let's begin with <b>tools</b>.</p>

<h4>13.1. Tools</h4>

<p>One tool you will most likely need to get familiar with: <b>x64dbg</b> <a href="https://x64dbg.com/">https://x64dbg.com/</a><br />
This is a "swiss-army knife" of any reverse engineer. It can do simple things and also very complex ones. For our needs, it
will be helpful to assemble the hooking code (custom event generator) - translate it to machine code bytes, essentially.
</p>

<p>Other tools you may find useful (although maybe not all of them):
<ul>
<li>a HEX editor of your choice
<li>a good calculator to convert between binary/decimal/hexadecimal numbers
</ul>
</p>

<h4>13.2. Custom event handler</h4>

<p>When talking about a custom event, it is useful to separate it into 2 parts:
<ol>
<li>Event generator</li>
<li>Event handler</li>
</ol>
</p>

<p>We are going to start with <b>Event handler</b> because it should be mostly familiar: if you
had written a module before, you should have a good idea of what an event handler function is.
Custom event handler is a function that you would define in your Lua module - very similar to how you would define a handler
function for any "normal" event that is generated by sider. It has the following specification ("signature" in CS-speak):
</p>
<p class="func">
function handler(ctx, event_id, registers)
</p>
<p>
<ul>
<li>ctx: is the usual variable holding the sider context table. Just like in most regular events</li>
<li>event_id: unique id for the particular custom event. We'll talk about it more later</li>
<li>registers: a table holding the values of CPU registers at the moment when event generator triggered the custom event.
The keys of the table are lower-case register names, such as <b>rax</b>, <b>rbx</b>, <b>r8</b>, and so on.
The values are binary strings containing register values in little-endian order of bytes. The reason those
are not regular Lua numbers is because some of the registers are actually quite large, and there is no
type equivalent for them in Lua/LuaJIT.</li>
</ul>
</p>

<p>The handler function is expected to return 1 value: <b>nil</b> or a table of registers that need to be modified.
If you don't want to modify registers in any way, just return nothing or <b>nil</b> or an empty table. If you want
to modify one or more registers, return a table with just those.</p>

<p>Here is an example of event handler:<br/>
<pre>
function m.finish_quickly(ctx, event_id, registers)
    log(string.format("custom:check_end_of_half (event_id:%s, registers:%s)", event_id, registers))
    log_registers(registers)

    -- set end-of-half flag
    return {
        -- rax is 8 bytes long.
        -- set the lowest byte to 1, but keep the higher bytes as they were
        rax = "\x01" .. registers.rax:sub(2,8)  -- set al = 1
    }
end
</pre>
</p>

<p>We register the handler function the exact same as we do with normal sider events.
Typically, inside the module's <b>init</b> function:<br/>
<pre>
function m.init(ctx)
    ...
    ctx.register("custom:check_end_of_half", m.finish_quickly)
    ...
end
</pre>
</p>

<p>The name of the custom event always starts with "custom:" prefix, but after that it is up to
the module author to come up with a good name. It must be unique across all Lua modules that
you are using</p>

<h4>13.3. Custom event generator</h4>

<p><b>Event generator</b> is the code that runs as part of the game process at a very specific moment.
For example, let's say that through some research and experiment, you have found a place in the
game process (PES2021.exe), where the player is shown the yellow card by the referee, and the player ID
is stored in a register - let's say R10, for example. Or, another scenario could be: the game is
checking whether the current half is over or not. You want to notify you Lua module when this
is happening. The way to do that is patch the game process with some new logic that tells sider: "this
particular event is happening right now, go tell all Lua modules that are interested in it". This
new logic is the event generator.</p>

<p>Let's continue with the "check_end_of_half" example. Here is where the game checks whether the current
half is over:
</p>
<p><img src="cevt1.png" style="border: 1px solid #888"/>
</p>
<p>First part of the function checks for normal time, second half - for extra time. The contents of <b>r8b</b>
register determines which type of half it is.
</p>
<p>Now, let's say we want to patch this code and put a custom event generator here that would call back
into sider in a special way so that sider calls all the event handlers that registered for our event.
</p>
<p>For now, let's write the event generator manually, using the assembler feature of <b>x64dbg</b>. (Later
on, we will instead have the Lua module do that, but right now, it is useful to see how this is done
using the debuggger). Starting right at that first instruction, press "Space" and write the code as
shown in the screenshot below. <b>x64dbg</b> will highlight the assembled bytes in red color:
</p>
<p><img src="cevt2.png" style="border: 1px solid #888"/>
</p>
<p>
This little code snippet shows how to use sider's custom event API (Application Programming Interface).<br />
Essentially, we need to call sider's "sider_custom_event_rbx_hk" function. It is
written in assembly language, and it expects to receive two values on the stack:
<ul>
<li>original value of <b>rbx</b> register</li>
<li>original value or <b>rcx</b> register</li>
</ul>
Those are needed so that sider can pass the actual values of all the registers, including what was in <b>rbx</b>
and <b>rcx</b> before the event generator code altered them. The generator code needs to modify them, because: <b>cx</b> must
contain the unique event id of this custom event, and <b>rbx</b> must used as an address holder for the far call
to "sider_custom_event_rbx_hk" function (the "call rbx" instruction).
</p>
<p>The address of the "sider_custom_event_rbx_hk" function is not fixed, it can change from one game session to
another, so it cannot be hardcorded to some number, but instead needs to be determined at run-time - we will see
how to do that very soon, when we have Lua module write the event generator code, instead of doing it manually.
</p>
<p>Same goes for event id. Those are fixed, but instead "allocated" by sider, based on custom event name.
In our example this name is <b>custom:end_of_half_check</b>. Sider provides is a utility function to find out
what the event id is for any given custom event name.</p>
<p>
After the call is done, stack needs to be restored to its original state, so the two values we pushed on
to it, need to popped back, but we don't need the actual values, so we do:
<pre>
add rsp, 10h</pre>
</p>
<p>Lastly, depending on the specific scenario, you may or may not need to write code to compensate for the
fact that we've overwritten some original game code. In this particular scenario, we don't actually need to do
that, because the end effect of the original function was to set register <b>al</b> either to 0 or to 1, where
1 means: end of the half. Since our <b>event handler</b> returns the registers it wants sider to modify, it
can return modified <b>rax</b> if it chooses to do so. Nothing else is needed here.</p>
</p>

<h4>13.4 Custom event generator: in a Lua module</h4>

<p>Now, it was mentioned that two things are not really known until the game is running: the address of
"sider_custom_event_rbx_hk" function, and which custom event id corresponds to which custom event name.
That is the first reason why you don't want to manually patch the code, using a debugger, such as x64dbg.
Another reason is that it is just too much hassle to do so every time, and we simply want to start the
game as we normally would, and not worry about all the hackery.</p>

<p>So we need to have the game patched on-the-fly with the <b>event generator</b> code. It is actually
not very difficult to do, thanks to the already existing facilities in sider. The memory library comes
in handy - first to find the right spot in the game process, and then to patch it. Let's see how it is done
for out example of custom event called "<b>custom:check_end_of_half</b>"</p>

<p>First, we need to determine the address at which we need to patch the game. While you could hardcode it
to a specific value (that you had found during your research), i don't recommend doing it that way, because
different versions of PES2021.exe will slightly different address. Instead, what you can do is use
<b>memory.search_process</b> function to dynamically locate the spot you are interested in, because it is
usually very easy to find a unique sequence of bytes right at the place you are looking for, or maybe slightly
before or after. This is how we can do it:
</p>
<pre>
    -- find the place where want to hook
    --[[
    0000000140A6C54A | 45:84C0                         | test r8b,r8b                            |
    0000000140A6C54D | 75 13                           | jne pes2021.140A6C562                   |
    0000000140A6C54F | F3:0F1005 B147BE01              | movss xmm0,dword ptr ds:[142650D08]     |
    0000000140A6C557 | F3:0F58C2                       | addss xmm0,xmm2                         |
    0000000140A6C55B | 0F2FD8                          | comiss xmm3,xmm0                        |
    0000000140A6C55E | 0F93C0                          | setae al                                |
    0000000140A6C561 | C3                              | ret                                     |
    0000000140A6C562 | F3:0F1005 9A47BE01              | movss xmm0,dword ptr ds:[142650D04]     |
    0000000140A6C56A | F3:0F58C2                       | addss xmm0,xmm2                         |
    0000000140A6C56E | 0F2FD8                          | comiss xmm3,xmm0                        |
    0000000140A6C571 | 0F93C0                          | setae al                                |
    0000000140A6C574 | C3                              | ret                                     |
    --]]
    local addr = memory.search_process("\xf3\x0f\x58\xc2\x0f\x2f\xd8\x0f\x93\xc0\xc3\xf3\x0f\x10\x05")
    if addr == nil then
        error("code location not found")
    end
    addr = addr - 0x57 + 0x4a
    log("code location: " .. memory.hex(addr))
</pre>

<p>The top part is just some comments that are helpful to see what code we are searchin for.
Then the call to <b>memory.search_process</b> function does the search. Notice, that we are looking
for the byte sequence that starts a little bit later, not at the exact place that we want to start
modifying the code. So, then once that location is found, we adjust it to point to the actual
starting place (<b>test r8b, r8b</b> instruction).
</p>

<p>Now that we have the location, let's put our event generator code in there:
</p>
<pre>
    -- get event_id for our custom event name
    local event_id = ctx.get_event_id("custom:check_end_of_half")

    -- place event trigger right there, overwriting existing code
    memory.write(addr,
        "\x53" ..                                                   -- push rbx
        "\x51" ..                                                   -- push rcx
        "\x48\xbb" .. memory.pack("u64", ctx.custom_evt_rbx) ..     -- mov rbx, {sider_custom_event_rbx_hk}
        "\x66\xb9" .. memory.pack("u16", event_id) ..               -- mov cx, {event_id}
        "\xff\xd3" ..                                               -- call rbx
        "\x48\x83\xc4\x10" ..                                       -- add rsp,10h
        "\xc3"                                                      -- ret
    )
</pre>

<p>Three main things of note here:
<ol>
<li>The call to <b>ctx.get_event_id</b> function - to determine what event id we should use</li>
<li>Using <b>ctx.custom_evt_rbx</b> as the address of "sider_custom_event_rbx_hk" function, packing it into a binary string</li>
<li>Using <b>event_id</b> that was determined earlier, and packing it into a binary string</li>
</ol>
</p>

<p>You will notice the rest of the machine code is basically taken from our earlier exercise, when we were assembling the event
generator code in x64dbg. Now that machine code comes in handy :).</p>

<p>And that is pretty much all there is to it!<br />
Well, not really, but hopefully this guide gives you a good starting point on how to create your own custom events.
</p>

<h4>13.5 Example modules</h4>

<p>Included with sider are two example modules: <span class="file">customevt1.lua</span> and <span class="file">customevt2.lua</span></p>

<p>The first one - customevt1.lua - is essentially the complete module that puts together all the code snippets and concepts that
were discussed above in this guide into a working module that both generates a custom event and also handles it. The event generator
triggers an event called "<b>custom:check_end_of_half</b>", when the game actually checks if the half is over or not yet. Then event
handler modifies <b>rax</b> register to set its lowest 8 bits ("AL") to 1, which tells the game that the half is over. So, basically,
as soon as each half of the match starts, it pretty much finishes right away. Yes, I know, it is not very useful... but it
demonstrates how custom events work.</p>

<p>The second one - customevt2.lua - works pretty much exactly the same way: short-circuits each half of the match. The only difference
is that it uses yet another technique, when patching the game process with the event generator code: it allocates a new code page in the
process memory - using new <b>memory.allocate_codecave</b> function, puts the event generator code there, then does an indirect jump to
that address. This is useful, when you don't have too many bytes to work with in the original location and you want as small of a
footprint as possible for a jump out to the event generator code.</p>

<hr/>
<p>
<a href="#">Back to top</a> |
<a href="scripting.html">Back to scripting guide</a> |
<a href="readme.html">Back to readme</a>
</p>

</body>
</html>
